{
    "language": "Solidity",
    "sources": {
        "Address.sol": {
          "keccak256": "0x26aecb5c7cbed0c55cff6d0c24fa7aaafee116c8d57a6241902c6997a73d5ef4",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length \u003e 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"
        },
        "Context.sol": {
          "keccak256": "0xedfcaf1423836c8e99b0425894e842a62a20cd6f776749a287804eb79d822791",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n"
        },
        "IBEP20.sol": {
          "keccak256": "0x3fe22ec1854bde47c40ca2c7663f7b0da9450d222aa1fb7c4d8a42f66a07d4b0",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\ninterface IBEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function getOwner() external view returns (address);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from,address indexed to,uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
        },
        "Ownable.sol": {
          "keccak256": "0x55a1023c62731b4be37fb88d62481a9f7d56f34f226892189b273c686906fab9",
          "content": "// SPDX-License-Identifier: None\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nimport \"./Context.sol\";\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
        },
        "ReentrancyGuard.sol": {
          "keccak256": "0x9f1a66f01888b5cafa12a7748e13cd510e2bf6573d0f20a48dde90821276d2f4",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    \r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        \r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"
        },
        "SafeBEP20.sol": {
          "keccak256": "0x23942d358868e81e65f56b60806a6867f28d7f4e9b6964a66a081cd654793662",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IBEP20.sol\";\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeBEP20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeBEP20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeBEP20: low-level call failed\");\r\n\r\n        if (returndata.length \u003e 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}"
        },
        "SafeMath.sol": {
          "keccak256": "0x3d96d20942b224876266b586ffb77dc121a7fd514ecc20ed42082d28124c1f74",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c \u003c a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    \r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b \u003e a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    \r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    \r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    \r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
        },
        "YFUNIuEarn.sol": {
          "keccak256": "0xccd1e4186ed39bc9e984bd8f2d58da58050a14f7c73fd2984b9e0ac2e0979c68",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nimport \"./uEarn.sol\";\r\n\r\ncontract YFUNIuEarn is uEarn{\r\n    using SafeBEP20 for IBEP20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    mapping (uint256 =\u003e eventStaking) private stakingEvent;\r\n    mapping (uint256 =\u003e uint256) private totalClaimed;\r\n    mapping (uint256 =\u003e address) private rewardAddress;\r\n    mapping (address =\u003e mapping (uint256 =\u003e bool)) private eventClaim;\r\n    \r\n    uint256 private activeEventId;\r\n    uint256[] private events;\r\n    \r\n    struct eventStaking{\r\n        bool stakeMustActive;\r\n        uint256 poolIdGotEvent;\r\n        uint256 dateRange1;\r\n        uint256 dateRange2;\r\n        uint256 stakeTimeElapsed;\r\n        uint256 snapshotReward;\r\n        uint256 totalReward;\r\n    }\r\n    \r\n    struct pairLooker{\r\n        uint8 pair2decimal;\r\n        address pair2address;\r\n        string pair2symbol;\r\n    }\r\n    \r\n    struct userLooker{\r\n        bool activestake;\r\n        uint256 periodChoosed;\r\n        uint256 pairChoosed;\r\n        uint256 amountstaked;\r\n        uint256 startstake;\r\n        uint256 reaminingReward;\r\n    }\r\n    \r\n    constructor (address data) {\r\n        _setAdmin(data);\r\n    }\r\n    \r\n    function createNewEvent(uint256 specificPoolId, uint256 startDateFilter, uint256 endDateFilter, uint256 specificElapsedTime, uint256 totalReward) external payable virtual onlyOwner nonReentrant{\r\n        (\r\n            uint8 pair2decimal,\r\n            address pair2address,\r\n            string memory pair2symbol  \r\n        ) = _getPairInfoForEvent(specificPoolId);\r\n        pairLooker memory sp = pairLooker(pair2decimal, pair2address, pair2symbol);\r\n        \r\n        require(specificPoolId \u003e 0, \"Pool poolIdGotEvent must greater than 0\");\r\n        require(startDateFilter \u003e 0, \"Start date must greater than 0\");\r\n        require(endDateFilter \u003e 0, \"End date must greater than 0\");\r\n        require(getPoolBalance(sp.pair2address) \u003e getRewardAllocation(sp.pair2address), \"Pool reward must greater than reward allocation\");\r\n        \r\n        address msgSender = _msgSender();\r\n        uint256 getEventLength = events.length;\r\n        uint256 newEventId = getEventLength.add(1);\r\n        \r\n        eventStaking storage ev = stakingEvent[newEventId];\r\n        \r\n        ev.stakeMustActive = true;\r\n        ev.poolIdGotEvent = specificPoolId;\r\n        ev.dateRange1 = startDateFilter;\r\n        ev.dateRange2 = endDateFilter;\r\n        ev.stakeTimeElapsed = specificElapsedTime;\r\n        ev.snapshotReward = getRewardAllocation(sp.pair2address);\r\n        ev.totalReward = totalReward;\r\n        \r\n        if(sp.pair2address == address(0)){\r\n            require(msg.value \u003e= totalReward, \"Value reward must same with argument\");\r\n        }else{\r\n            uint256 getallowance = IBEP20(sp.pair2address).allowance(msgSender, address(this));\r\n            require(getallowance \u003e= totalReward, \"Insufficient token approval balance, you must increase your allowance\" );\r\n            IBEP20(sp.pair2address).safeTransferFrom(msgSender, address(this), totalReward);\r\n        }\r\n        \r\n        rewardAddress[newEventId] = sp.pair2address;\r\n        activeEventId = newEventId;\r\n        events.push(newEventId);\r\n    }\r\n    \r\n    function closeActiveEvent() external virtual onlyOwner nonReentrant{\r\n        eventStaking storage ev = stakingEvent[activeEventId];\r\n        uint256 ream = ev.totalReward.sub(totalClaimed[activeEventId]);\r\n        totalClaimed[activeEventId] = totalClaimed[activeEventId].add(ream);\r\n        activeEventId = 0;\r\n    }\r\n    \r\n    function userEventClaim() external virtual nonReentrant{\r\n        address msgSender = _msgSender();\r\n        \r\n        require(checkEligibleUser(msgSender, activeEventId) == true, \"Unfortunately, you not eligible\");\r\n        \r\n        uint256 getUserAllocationReward = userRewardCalculator(msgSender, activeEventId);\r\n        eventClaim[msgSender][activeEventId] = true;\r\n        totalClaimed[activeEventId] = totalClaimed[activeEventId].add(getUserAllocationReward);\r\n        \r\n        if(viewActiveRewardAddress() == address(0)){\r\n            payable(msgSender).transfer(getUserAllocationReward);\r\n        }else{\r\n            IBEP20(viewActiveRewardAddress()).safeTransfer(msgSender, getUserAllocationReward);\r\n        }\r\n    }\r\n    \r\n    function viewDetailEvent(uint256 eventId) public view returns(bool, uint, uint256, uint256, uint256, uint256, uint256){\r\n        eventStaking storage ev = stakingEvent[eventId];\r\n        \r\n        return(\r\n            ev.stakeMustActive,\r\n            ev.poolIdGotEvent,\r\n            ev.dateRange1,\r\n            ev.dateRange2,\r\n            ev.stakeTimeElapsed,\r\n            ev.snapshotReward,\r\n            ev.totalReward\r\n        );\r\n    }\r\n    \r\n    function viewReaminingReward(uint256 eventId) public view returns(uint256){\r\n        eventStaking storage ev = stakingEvent[eventId];\r\n        uint256 ream = ev.totalReward.sub(totalClaimed[eventId]);\r\n        return ream;\r\n    }\r\n    \r\n    function viewActiveEvent() public view returns(uint){\r\n        return activeEventId;\r\n    }\r\n    \r\n    function viewActiveRewardAddress() public view returns(address){\r\n        return rewardAddress[activeEventId];\r\n    }\r\n    \r\n    function checkEligibleUser(address participant, uint256 eventId) public view returns(bool){\r\n        bool eligibledUser = false;\r\n        \r\n        if(eventClaim[participant][eventId] == false){\r\n            if(_checkEligibleEvent(participant, eventId) == true){\r\n                eligibledUser = true;\r\n            }\r\n        }\r\n        \r\n        return eligibledUser;\r\n    }\r\n    \r\n    function userRewardCalculator(address participant, uint256 eventId) public view returns(uint256){\r\n        (\r\n            bool activestake,\r\n            uint256 periodChoosed,\r\n            uint256 pairChoosed,\r\n            uint256 amountstaked,\r\n            uint256 startstake,\r\n            uint256 reaminingReward\r\n        ) = _getUserInfo(participant);\r\n        \r\n        eventStaking memory ev = stakingEvent[eventId];\r\n        userLooker memory lookup = userLooker(activestake, periodChoosed, pairChoosed, amountstaked, startstake, reaminingReward);\r\n        \r\n        uint256 getUserReward;\r\n        \r\n        if(lookup.reaminingReward \u003e 0){\r\n            uint256 getTotalReward = ev.totalReward;\r\n            uint256 getUserReaminingReward = lookup.reaminingReward;\r\n            uint256 getTotalAllocation = ev.snapshotReward;\r\n            \r\n            getUserReward = getTotalReward.mul(getUserReaminingReward);\r\n            getUserReward = getUserReward.div(getTotalAllocation);\r\n        }\r\n        \r\n        return getUserReward;\r\n    }\r\n    \r\n    function _checkEligibleEvent(address participant, uint256 eventId) internal view returns(bool){\r\n        (\r\n            bool activestake,\r\n            uint256 periodChoosed,\r\n            uint256 pairChoosed,\r\n            uint256 amountstaked,\r\n            uint256 startstake,\r\n            uint256 reaminingReward\r\n        ) = _getUserInfo(participant);\r\n        \r\n        eventStaking memory ev = stakingEvent[eventId];\r\n        userLooker memory lookup = userLooker(activestake, periodChoosed, pairChoosed, amountstaked, startstake, reaminingReward);\r\n        \r\n        bool statusActiveCheck = false;\r\n        bool periodChoosedCheck = false;\r\n        bool startDateUnderRangeCheck = false;\r\n        bool stakeElapsedTimeCheck = false;\r\n        bool isEligible = false;\r\n        \r\n        if(ev.stakeMustActive == true){\r\n            if(lookup.activestake == ev.stakeMustActive){\r\n                statusActiveCheck = true;\r\n            }\r\n        }else{\r\n            statusActiveCheck = true;\r\n        }\r\n        \r\n        if(ev.poolIdGotEvent == 0){\r\n            periodChoosedCheck = true;\r\n        }else{\r\n            if(lookup.pairChoosed == ev.poolIdGotEvent){\r\n                periodChoosedCheck = true;\r\n            }\r\n        }\r\n        \r\n        if(lookup.startstake \u003e= ev.dateRange1 \u0026\u0026 ev.dateRange2 \u003e= lookup.startstake){\r\n            startDateUnderRangeCheck = true;\r\n        }\r\n        \r\n        if((block.timestamp - lookup.startstake) \u003e= ev.stakeTimeElapsed){\r\n            stakeElapsedTimeCheck = true;\r\n        }\r\n        \r\n        if(statusActiveCheck == true \u0026\u0026 periodChoosedCheck == true \u0026\u0026 startDateUnderRangeCheck == true \u0026\u0026 stakeElapsedTimeCheck == true){\r\n            isEligible = true;\r\n        }\r\n        \r\n        return isEligible;\r\n    }\r\n}"
        },
        "uEarn.sol": {
          "keccak256": "0x1561daa741e8e5020e1650a89940388216c7632c4e8c7d3c343e4610913ba328",
          "content": "// SPDX-License-Identifier: none\r\n\r\npragma solidity \u003e=0.7.2 \u003c0.9.0;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeBEP20.sol\";\r\n\r\nabstract contract uEarn is Context, Ownable, ReentrancyGuard {\r\n    using SafeBEP20 for IBEP20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    struct userstaking{\r\n        bool activestake;\r\n        uint256 periodChoosed;\r\n        uint256 pairChoosed;\r\n        uint256 amountstaked;\r\n        uint256 startstake;\r\n        uint256 claimstake;\r\n        uint256 endstake;\r\n        uint256 cooldownDate;\r\n        uint256 claimed;\r\n        uint256 reaminingReward;\r\n        uint256 equalPair1;\r\n        uint256 equalPair2;\r\n        uint256 formulaParam1;\r\n        uint256 formulaParam2;\r\n    }\r\n    \r\n    struct pairToken{\r\n        uint8 pair1decimal;\r\n        uint8 pair2decimal;\r\n        uint256 minStake;\r\n        uint256 equalPair1;\r\n        uint256 equalPair2;\r\n        uint256 formulaParam1;\r\n        uint256 formulaParam2;\r\n        uint256 formulaDivide1;\r\n        uint256 formulaDivide2;\r\n        uint256 formulaDivClaim1;\r\n        uint256 formulaDivClaim2;\r\n        address pair1address;\r\n        address pair2address;\r\n        string pair1symbol;\r\n        string pair2symbol;\r\n    }\r\n    \r\n    mapping (uint256 =\u003e uint256) private period;\r\n    mapping (address =\u003e userstaking) private stakeDetail;\r\n    mapping (address =\u003e uint256) private devBalance;\r\n    mapping (uint256 =\u003e pairToken) private pairTokenList;\r\n    mapping (address =\u003e uint256) private allocatedForUser;\r\n    \r\n    address private _owner;\r\n    address private _admin;\r\n    uint256[] private _tokenPairList;\r\n    uint256[] private _periodList;\r\n    \r\n    event stake(address indexed staker, address indexed tokenstakeTarget, uint256 indexed amountTokenstaked);\r\n    event Unstake(address indexed staker, address indexed tokenstakeTarget, uint256 indexed amountTokenstaked);\r\n    event Claim(address indexed staker, address indexed tokenstakeTarget, uint256 indexed amountReward);\r\n    \r\n    constructor(){\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    \r\n    function addTokenPair(address addrpair1, address addrpair2, string memory symbolpair1, string memory symbolpair2, uint256 minstake, uint8 decimalpair1, uint8 decimalpair2) external virtual onlyOwner nonReentrant{\r\n        uint256 newPair = _tokenPairList.length;\r\n        if(newPair == 0){\r\n            newPair = 1;\r\n        }else{\r\n            newPair = newPair + 1;\r\n        }\r\n        \r\n        pairToken storage vp = pairTokenList[newPair];\r\n        \r\n        vp.pair1decimal = decimalpair1;\r\n        vp.pair2decimal = decimalpair2;\r\n        vp.minStake = minstake;\r\n        vp.pair1address = addrpair1;\r\n        vp.pair2address = addrpair2;\r\n        vp.pair1symbol = symbolpair1;\r\n        vp.pair2symbol = symbolpair2;\r\n        \r\n         _tokenPairList.push(newPair);\r\n    }\r\n    \r\n    function editTokenPair(uint256 pairId, address addrpair1, address addrpair2, string memory symbolpair1, string memory symbolpair2, uint256 minstake, uint8 decimalpair1, uint8 decimalpair2) external virtual onlyOwner nonReentrant{\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        \r\n        vp.pair1decimal = decimalpair1;\r\n        vp.pair2decimal = decimalpair2;\r\n        vp.minStake = minstake;\r\n        vp.pair1address = addrpair1;\r\n        vp.pair2address = addrpair2;\r\n        vp.pair1symbol = symbolpair1;\r\n        vp.pair2symbol = symbolpair2;\r\n    }\r\n    \r\n    function editTokenPairOption(uint256 pairId, uint256 fpel1, uint256 fpel2, uint256 fclm1, uint256 fclm2, uint256 formula1, uint256 formula2, uint256 equalpair1, uint256 equalpair2) external virtual onlyOwner nonReentrant{\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        \r\n        vp.equalPair1 = equalpair1;\r\n        vp.equalPair2 = equalpair2;\r\n        vp.formulaDivide1 = fpel1;\r\n        vp.formulaDivide2 = fpel2;\r\n        vp.formulaDivClaim1 = fclm1;\r\n        vp.formulaDivClaim2 = fclm2;\r\n        vp.formulaParam1 = formula1;\r\n        vp.formulaParam2 = formula2;\r\n    }\r\n    \r\n    function addPeriod(uint256 timePeriodstake) external virtual onlyOwner nonReentrant{\r\n        uint256 newPeriod = _periodList.length;\r\n        if(newPeriod == 0){\r\n            newPeriod = 1;\r\n        }else{\r\n            newPeriod = newPeriod + 1;\r\n        }\r\n        \r\n        period[newPeriod] = timePeriodstake;\r\n        _periodList.push(newPeriod);\r\n    }\r\n    \r\n    function editPeriod(uint256 periodEdit, uint256 timePeriodstake) external virtual onlyOwner nonReentrant{\r\n        period[periodEdit] = timePeriodstake;\r\n    }\r\n    \r\n    function claimDevBalance(address target) external virtual onlyOwner nonReentrant{\r\n        uint256 forAdmin = devBalance[target].mul(10);\r\n        forAdmin = forAdmin.div(100);\r\n        uint256 forOwner = devBalance[target].sub(forAdmin);\r\n        if(target == address(0)){\r\n            payable(_owner).transfer(forOwner);\r\n            payable(_admin).transfer(forAdmin);\r\n        }else{\r\n            IBEP20(target).safeTransfer(_owner, forOwner);\r\n            IBEP20(target).safeTransfer(_admin, forAdmin);\r\n        }\r\n        \r\n        devBalance[target] = 0;\r\n    }\r\n    \r\n    function claimPoolToDev(address target) external virtual onlyOwner nonReentrant{\r\n        if(target == address(0)){\r\n            payable(_owner).transfer(getPoolBalance(target));\r\n        }else{\r\n            IBEP20(target).safeTransfer(_owner, getPoolBalance(target));\r\n        }\r\n    }\r\n    \r\n    function claimReward() external virtual nonReentrant{\r\n        address msgSender = _msgSender();\r\n        userstaking storage usr = stakeDetail[msgSender];\r\n        pairToken storage vp = pairTokenList[usr.pairChoosed];\r\n        uint256 getrewardbalance = IBEP20(vp.pair2address).balanceOf(address(this));\r\n        uint256 getReward = getRewardClaimable(msgSender);\r\n        uint256 today = block.timestamp;\r\n        \r\n        require(getrewardbalance \u003e= getReward, \"Please wait until reward pool filled, try again later.\");\r\n        require(usr.claimstake \u003c block.timestamp, \"Please wait until wait time reached.\");\r\n        \r\n        usr.claimed = usr.claimed.add(getReward);\r\n        usr.claimstake = today.add(1 days);\r\n        usr.cooldownDate = today.add(1 days);\r\n        usr.reaminingReward = usr.reaminingReward.sub(getReward);\r\n        allocatedForUser[vp.pair2address] = allocatedForUser[vp.pair2address].sub(getReward);\r\n        \r\n        uint256 tokenClaim;\r\n        if(vp.formulaDivClaim1 \u003e 0 \u0026\u0026 vp.formulaDivClaim2 \u003e 0){\r\n            uint256 penfee = getReward.mul(vp.formulaDivClaim1);\r\n            penfee = penfee.div(vp.formulaDivClaim2);\r\n            penfee = penfee.div(100);\r\n            tokenClaim = getReward.sub(penfee);\r\n            devBalance[vp.pair2address] = devBalance[vp.pair2address].add(penfee);\r\n        }else{\r\n            tokenClaim = getReward;\r\n        }\r\n        IBEP20(vp.pair2address).safeTransfer(msgSender, tokenClaim);\r\n        emit Claim(msgSender, vp.pair2address, getReward);\r\n    }\r\n    \r\n    function stakeNow(uint256 pairId, uint256 amountWantstake, uint256 periodwant) external payable virtual nonReentrant{\r\n        address msgSender = _msgSender();\r\n        if(getRewardClaimable(msgSender) \u003e 0){\r\n            revert(\"Please claim your reward from previous stakeing\");\r\n        }\r\n        \r\n        uint256 today = block.timestamp;\r\n        userstaking storage usr = stakeDetail[msgSender];\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        \r\n        require(getPoolBalance(vp.pair2address) \u003e= getRewardCalculator(pairId, amountWantstake, periodwant), \"Insufficient reward pool token, please wait and try again later.\");\r\n        \r\n        if(vp.pair2address == address(0)){\r\n            require(msg.value \u003e= vp.minStake, \"Minimum stakeing value required\");\r\n        }else{\r\n            uint256 getallowance = IBEP20(vp.pair1address).allowance(msgSender, address(this));\r\n            require(amountWantstake \u003e= vp.minStake, \"Minimum staking value required\");\r\n            require(getallowance \u003e= amountWantstake, \"Insufficient token approval balance, you must increase your allowance\" );\r\n            IBEP20(vp.pair1address).safeTransferFrom(msgSender, address(this), amountWantstake);\r\n        }\r\n        \r\n        usr.activestake = true;\r\n        usr.periodChoosed = periodwant;\r\n        usr.pairChoosed = pairId;\r\n        usr.amountstaked = amountWantstake;\r\n        usr.startstake = today;\r\n        usr.claimstake = today.add(1 days);\r\n        usr.cooldownDate = today.add(1 days);\r\n        usr.endstake = today.add(period[periodwant]);\r\n        usr.claimed = 0;\r\n        usr.formulaParam1 = vp.formulaParam1;\r\n        usr.formulaParam2 = vp.formulaParam2;\r\n        usr.equalPair1 = vp.equalPair1;\r\n        usr.equalPair2 = vp.equalPair2;\r\n        usr.reaminingReward = usr.reaminingReward.add(getRewardCalculator(pairId, amountWantstake, periodwant));\r\n        \r\n        allocatedForUser[vp.pair2address] = allocatedForUser[vp.pair2address].add(getRewardCalculator(pairId, amountWantstake, periodwant));\r\n        \r\n        emit stake(msgSender, vp.pair2address, amountWantstake);\r\n    }\r\n    \r\n    function unstakeNow() external virtual nonReentrant{\r\n        address msgSender = _msgSender();\r\n        userstaking storage usr = stakeDetail[msgSender];\r\n        pairToken storage vp = pairTokenList[usr.pairChoosed];\r\n        \r\n        require(usr.cooldownDate \u003c block.timestamp, \"Please wait until cooldown time reached\");\r\n        require(usr.activestake == true, \"stake not active yet\" );\r\n        \r\n        uint256 tokenUnstake;\r\n        if(vp.formulaDivide1 \u003e 0 \u0026\u0026 vp.formulaDivide2 \u003e 0){\r\n            uint256 penfee = usr.amountstaked.mul(vp.formulaDivide1);\r\n            penfee = penfee.div(vp.formulaDivide2);\r\n            penfee = penfee.div(100);\r\n            tokenUnstake = usr.amountstaked.sub(penfee);\r\n            devBalance[vp.pair1address] = devBalance[vp.pair1address].add(penfee);\r\n        }else{\r\n            tokenUnstake = usr.amountstaked;\r\n        }\r\n        \r\n        usr.activestake = false;\r\n        if(block.timestamp \u003c usr.endstake){\r\n            usr.endstake = block.timestamp;\r\n        }\r\n        \r\n        if(vp.pair1address == address(0)){\r\n            payable(msgSender).transfer(tokenUnstake);\r\n        }else{\r\n            IBEP20(vp.pair1address).safeTransfer(msgSender, tokenUnstake);\r\n        }\r\n        \r\n        uint256 getCLaimableRwt = getRewardClaimable(msgSender);\r\n        \r\n        if(getCLaimableRwt \u003e 0){\r\n            uint256 tokenClaim;\r\n            if(vp.formulaDivClaim1 \u003e 0 \u0026\u0026 vp.formulaDivClaim2 \u003e 0){\r\n                uint256 penfee = getCLaimableRwt.mul(vp.formulaDivClaim1);\r\n                penfee = penfee.div(vp.formulaDivClaim2);\r\n                penfee = penfee.div(100);\r\n                tokenClaim = getCLaimableRwt.sub(penfee);\r\n                devBalance[vp.pair2address] = devBalance[vp.pair2address].add(penfee);\r\n            }else{\r\n                tokenClaim = getCLaimableRwt;\r\n            }\r\n            \r\n            usr.claimed = usr.claimed.add(getCLaimableRwt);\r\n            usr.reaminingReward = usr.reaminingReward.sub(getCLaimableRwt);\r\n            allocatedForUser[vp.pair2address] = allocatedForUser[vp.pair2address].sub(getCLaimableRwt);\r\n            \r\n            if(usr.reaminingReward \u003e 0){\r\n                devBalance[vp.pair2address] = devBalance[vp.pair2address].add(usr.reaminingReward);\r\n                allocatedForUser[vp.pair2address] = allocatedForUser[vp.pair2address].sub(usr.reaminingReward);\r\n                usr.reaminingReward = 0;\r\n            }\r\n            \r\n            IBEP20(vp.pair2address).safeTransfer(msgSender, tokenClaim);\r\n        }\r\n        \r\n        emit Unstake(msgSender, vp.pair1address, usr.amountstaked);\r\n        emit Claim(msgSender, vp.pair2address, getCLaimableRwt);\r\n    }\r\n    \r\n    function getDevBalance(address target) external view returns(uint256){\r\n        return devBalance[target];\r\n    }\r\n    \r\n    function getPoolBalance(address target) public view returns(uint256){\r\n        uint256 bal;\r\n        \r\n        if(target == address(0)){\r\n            bal = address(this).balance;\r\n        }else{\r\n            bal = IBEP20(target).balanceOf(address(this));\r\n        }\r\n        \r\n        uint256 poolbal = bal.sub(devBalance[target]);\r\n        poolbal = poolbal.sub(allocatedForUser[target]);\r\n        return poolbal;\r\n    }\r\n    \r\n    function getPairInfo(uint256 pairId) public view returns(uint8, uint8, uint256, address, address, string memory, string memory){\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        return(\r\n            vp.pair1decimal,\r\n            vp.pair2decimal,\r\n            vp.minStake,\r\n            vp.pair1address,\r\n            vp.pair2address,\r\n            vp.pair1symbol,\r\n            vp.pair2symbol\r\n        );\r\n    }\r\n    \r\n    function getPairOptionInfo(uint256 pairId) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        return(\r\n            vp.formulaDivide1,\r\n            vp.formulaDivide2,\r\n            vp.formulaDivClaim1,\r\n            vp.formulaDivClaim2,\r\n            vp.formulaParam1,\r\n            vp.formulaParam2,\r\n            vp.equalPair1,\r\n            vp.equalPair2\r\n        );\r\n    }\r\n    \r\n    function getPairList() public view returns(uint256[] memory){\r\n        return _tokenPairList;\r\n    }\r\n    \r\n    function getPeriodList() public view returns(uint256[] memory){\r\n        return _periodList;\r\n    }\r\n    \r\n    function getPeriodDetail(uint256 periodwant) public view returns(uint256){\r\n        return period[periodwant];\r\n    }\r\n    \r\n    function getRewardAllocation(address target) public view returns(uint256){\r\n        return allocatedForUser[target];\r\n    }\r\n    \r\n    function getUserInfo(address stakerAddress) public view returns(bool, uint, uint, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        userstaking storage usr = stakeDetail[stakerAddress];\r\n        \r\n        uint256 amountTotalstaked;\r\n        if(usr.activestake == false){\r\n            amountTotalstaked = 0;\r\n        }else{\r\n            amountTotalstaked = usr.amountstaked;\r\n        }\r\n        return(\r\n            usr.activestake,\r\n            usr.periodChoosed,\r\n            usr.pairChoosed,\r\n            amountTotalstaked,\r\n            usr.startstake,\r\n            usr.claimstake,\r\n            usr.endstake,\r\n            usr.cooldownDate,\r\n            usr.claimed\r\n        );\r\n    }\r\n    \r\n    function getUserSavedPairinfo(address stakerAddress) public view returns(uint256,uint256,uint256,uint256){\r\n        userstaking storage usr = stakeDetail[stakerAddress];\r\n        return(\r\n            usr.equalPair1,\r\n            usr.equalPair2,\r\n            usr.formulaParam1,\r\n            usr.formulaParam2 \r\n        );\r\n    }\r\n    \r\n    function getRewardClaimable(address stakerAddress) public view returns(uint256){\r\n        userstaking storage usr = stakeDetail[stakerAddress];\r\n        pairToken storage vp = pairTokenList[usr.pairChoosed];\r\n        \r\n        uint256 rewards;\r\n        \r\n        if(usr.amountstaked == 0 \u0026\u0026 vp.pair2address == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today \u003e usr.endstake){\r\n                diffTime = usr.endstake.sub(usr.startstake);\r\n            }else{\r\n                diffTime = today.sub(usr.startstake);\r\n            }\r\n            uint256 getMod = diffTime.mod(86400);\r\n            diffTime = diffTime.sub(getMod);\r\n            rewards = usr.amountstaked.mul(diffTime);\r\n            uint256 getTokenEqual = usr.equalPair2;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.mul(usr.formulaParam1);\r\n            rewards = rewards.div(10**vp.pair1decimal);\r\n            rewards = rewards.div(usr.formulaParam2);\r\n            rewards = rewards.div(100);\r\n            rewards = rewards.sub(usr.claimed);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardObtained(address stakerAddress) public view returns(uint256){\r\n        userstaking storage usr = stakeDetail[stakerAddress];\r\n        pairToken storage vp = pairTokenList[usr.pairChoosed];\r\n        uint256 rewards;\r\n        \r\n        if(usr.amountstaked == 0 \u0026\u0026 vp.pair2address == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today \u003e usr.endstake){\r\n                diffTime = usr.endstake.sub(usr.startstake);\r\n            }else{\r\n                diffTime = today.sub(usr.startstake);\r\n            }\r\n            uint256 getMod = diffTime.mod(86400);\r\n            diffTime = diffTime.sub(getMod);\r\n            rewards = usr.amountstaked.mul(diffTime);\r\n            uint256 getTokenEqual = usr.equalPair2;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.mul(usr.formulaParam1);\r\n            rewards = rewards.div(10**vp.pair1decimal);\r\n            rewards = rewards.div(usr.formulaParam2);\r\n            rewards = rewards.div(100);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardCalculator(uint256 pairId, uint256 amountWantstake, uint256 periodwant) public view returns(uint256){\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        \r\n        uint256 startDate = block.timestamp;\r\n        uint256 endDate = startDate.add(period[periodwant]);\r\n        uint256 diffTime = endDate.sub(startDate);\r\n        uint256 getMod = diffTime.mod(86400);\r\n        diffTime = diffTime.sub(getMod);\r\n        uint256 rewards = amountWantstake.mul(diffTime);\r\n        uint256 getTokenEqual = vp.equalPair2;\r\n        rewards = rewards.mul(getTokenEqual);\r\n        rewards = rewards.mul(vp.formulaParam1);\r\n        rewards = rewards.div(10**vp.pair1decimal);\r\n        rewards = rewards.div(vp.formulaParam2);\r\n        rewards = rewards.div(100);\r\n        return rewards;\r\n    }\r\n    \r\n    function _getPairInfoForEvent(uint256 pairId) internal view returns(uint8, address, string memory){\r\n        pairToken storage vp = pairTokenList[pairId];\r\n        return(\r\n            vp.pair2decimal,\r\n            vp.pair2address,\r\n            vp.pair2symbol\r\n        );\r\n    }\r\n    \r\n    function _getUserInfo(address stakerAddress) internal view returns(bool, uint, uint, uint256, uint256, uint256){\r\n        userstaking storage usr = stakeDetail[stakerAddress];\r\n        \r\n        uint256 amountTotalstaked;\r\n        if(usr.activestake == false){\r\n            amountTotalstaked = 0;\r\n        }else{\r\n            amountTotalstaked = usr.amountstaked;\r\n        }\r\n        return(\r\n            usr.activestake,\r\n            usr.periodChoosed,\r\n            usr.pairChoosed,\r\n            amountTotalstaked,\r\n            usr.startstake,\r\n            usr.reaminingReward\r\n        );\r\n    }\r\n    \r\n    function _setAdmin(address setAdmin) internal virtual onlyOwner nonReentrant{\r\n        _admin = setAdmin;\r\n    }\r\n}"
        }
    },
    "settings": {
        "remappings": [],
        "optimizer": {
          "enabled": true,
          "runs": 200
        },
        "evmVersion": "istanbul",
        "libraries": {},
        "outputSelection": {
            "*": {
                "*": [
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "abi"
                ]
            }
        }
    }
}